import * as ts from "typescript"
import globby = require("globby");
import path from "path";
import fs from "fs";
const { stat, writeFile, readFile, realpath } = fs.promises;
async function simpleStat(path: string) {
    try {
        return await stat(path);
    }
    catch {}
}

async function simpleRead(path: string) {
    try {
        return (await readFile(path)).toString();
    }
    catch {}
}

function intersectSets<T>(a: Set<T>, b: Set<T>) {
    return new Set(Array.from(a).filter(x => b.has(x)));
}

function isAutogenerated(configPath: string) {
    try {
        return !!require(configPath).autogenerated;
    }
    catch {}
    return false;
}

export async function generateConfigsInPlace(targetDir: string) {
    const packageFiles = await globby([path.join(targetDir, "**/package.json"), `!**/node_modules/**`, `!${path.join(targetDir, "package.json")}`]);
    console.log(`Discovered ${packageFiles.length} packages.`);
    if (packageFiles.length === 0) {
        return;
    }
    console.log(`Enumerating immediate dependencies of each...`);
    const nameToLocationMapping: { [index: string]: string } = {};
    const nameToDependencies: { [index: string]: Set<string> } = {};
    const packageContainsCircularMapping: { [index: string]: true | undefined } = {};
    for (let packagePath of packageFiles) {
        packagePath = await realpath(packagePath);
        const contents = require(packagePath);
        const packageRoot = path.dirname(packagePath);
        const name = path.normalize(contents.name);
        nameToLocationMapping[name] = packageRoot;
        const deps = new Set<string>();
        for (const depsKey of ["dependencies", "devDependencies", "peerDependencies", "optionalDependencies", "bundleDependencies"]) {
            if (contents[depsKey]) {
                const depsKeys = Object.keys(contents[depsKey]);
                for (const dep of depsKeys) {
                    deps.add(path.normalize(dep));
                }
            }
        }
        if (!deps.size) {
            console.log(`Package ${name} lists no explicit dependencies - scanning component typescript files for references...`);
            await fillDepsFromFileContents(deps, packageRoot);
        }
        nameToDependencies[name] = deps;
    }
    const possibleBaseConfigPath = path.join(targetDir, "tsconfig.json");
    const baseConfig = await simpleStat(possibleBaseConfigPath);
    const packageNames = new Set(Object.keys(nameToLocationMapping));
    for (const packageName in nameToLocationMapping) {
        const packageRoot = nameToLocationMapping[packageName];
        const tsconfigPath = path.join(packageRoot, "tsconfig.json");
        if (await simpleStat(tsconfigPath) && !isAutogenerated(tsconfigPath)) {
            console.log(`${packageName} has tsconfig, skipping...`);
            continue; // Don't write tsconfigs for packages which have one
            // TODO: Consider adding references to existing non-autogenerated `tsconfig`s?
        }
        console.log(`Generating tsconfig for ${packageName}...`);
        const deps = nameToDependencies[packageName];
        const referencableDeps = intersectSets(deps, packageNames);
        const candidateConfig = {
            autogenerated: true,
            base: baseConfig ? path.relative(path.dirname(tsconfigPath), possibleBaseConfigPath).replace(/\\/g, "/") : undefined,
            references: referencableDeps.size ? Array.from(referencableDeps).sort().map(d =>
                (d === packageName ? undefined : { path: path.relative(path.dirname(tsconfigPath), nameToLocationMapping[d]).replace(/\\/g, "/"), circular: packageContainsCircularMapping[d] = packageContainsCircularMapping[d] || dependsOn(d, packageName) })
            ).filter(x => !!x) : undefined,
            compilerOptions: {
                declaration: true,
                composite: referencableDeps.size ? true : undefined
            }
        };

        await writeFile(tsconfigPath, JSON.stringify(candidateConfig, null, 4));
    }
    console.log("Done!");
    const rootBuildConfigPath = path.join(targetDir, "tsconfig.build.json");
    const rootConfig = {
        autogenerated: true,
        base: baseConfig ? path.relative(path.dirname(rootBuildConfigPath), possibleBaseConfigPath).replace(/\\/g, "/") : undefined,
        references: packageNames.size ? Array.from(packageNames).sort().map(d =>
            ({ path: path.relative(path.dirname(rootBuildConfigPath), nameToLocationMapping[d]).replace(/\\/g, "/"), circular: packageContainsCircularMapping[d] })
        ) : undefined,
        compilerOptions: {
            declaration: true,
            composite: packageNames.size ? true : undefined
        }
    };
    await writeFile(rootBuildConfigPath, JSON.stringify(rootConfig, null, 4));

    function dependsOn(packageName: string, target: string, visitedList: Set<string> = new Set()) {
        const deps = nameToDependencies[packageName];
        for (const dep of Array.from(deps)) {
            if (dep === target) {
                return true;
            }
            if (visitedList.has(dep)) {
                continue;
            }
            if (!packageNames.has(dep)) return;
            visitedList.add(dep);
            if (dependsOn(dep, target, visitedList)) {
                return true;
            }
        }
    }
}

async function fillDepsFromFileContents(deps: Set<string>, packageRoot: string) {
    const glob = path.join(packageRoot, "**/*.ts");
    const tsFiles = await globby([glob, glob + "x", `!**/node_modules/**`]);
    await Promise.all(tsFiles.map(async (filePath) => {
        const contents = await simpleRead(filePath);
        if (!contents) return;
        const info = ts.preProcessFile(contents);
        for (const refKind of ["typeReferenceDirectives" as "typeReferenceDirectives", "importedFiles" as "importedFiles"]) {
            for (const file of info[refKind]) {
                const specifier = path.normalize(file.fileName);
                if (!specifier) continue;
                const parts = specifier.split(path.sep);
                if (specifier.startsWith("@")) {
                    deps.add(parts.slice(0, 2).join(path.sep));
                }
                if (!specifier.startsWith(".")) {
                    deps.add(parts[0]);
                }
            }
        }
    }));
}